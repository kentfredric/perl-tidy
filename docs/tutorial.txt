A Brief Perltidy Tutorial
    Perltidy can save you a lot of tedious editing if you spend a few
    minutes learning to use it effectively. There are a large number of
    options available for customizing it, but for many programmers the
    default parameter set will be satisfactory, with perhaps a few
    additional parameters to account for style preferences.

    This tutorial assumes that perltidy has been installed on your system.
    Installation instructions accompany the package. To follow along with
    this tutorial, please find a small Perl script and place a copy in a
    temporary directory. For example, here is a small script (from the book
    Learning Perl 2nd edition, by Randall Schwartz and Tom Christiansen
    <http://www.oreilly.com/catalog/lperl2/>):

     #Learning Perl Appendix A, Exercise 4.2
     print "What temperature is it? ";
     chop($temperature = <STDIN>);
     if ($temperature > 75) {
       print "Too hot!\n";
     } elsif ($temperature < 68) {
       print "Too cold!\n";
     } else {
       print "Just right!\n";
     }

    It is included in the docs section of the distribution.

  A First Test
    Assume that the name of your script is testfile.pl. You can reformat it
    with the default options to use the style recommended in the perlstyle
    man pages with the command:

     perltidy testfile.pl

    For safety, perltidy never overwrites your original file. In this case,
    its output will go to a file named testfile.pl.tdy, which you should
    examine now with your editor. Here is what the above file looks like
    with the default options:

     #Learning Perl Appendix A, Exercise 4.2
     print "What temperature is it? ";
     chop( $temperature = <STDIN> );
     if ( $temperature > 75 ) {
         print "Too hot!\n";
     }
     elsif ( $temperature < 68 ) {
         print "Too cold!\n";
     }
     else {
         print "Just right!\n";
     }

    You'll notice an immediate style change from the "cuddled-else" style of
    the original to the default "non-cuddled-else" style. This is because
    Perltidy has to make some kind of default selection of formatting
    options, and this default tries to follow the suggestions in the
    perlstyle man pages.

    If you prefer the original "cuddled-else" style you can indicate that
    with a -ce flag. So if you rerun with that flag

     perltidy -ce testfile.pl

    you will see a return to the original "cuddled-else" style. There are
    many more parameters for controlling style, and some of the most useful
    of these are discussed below.

  Indentation
    Another difference between the original file and the reformatted file is
    that the indentation has been changed from 2 spaces in the input file to
    4 spaces. You may change this to be a different number with -i=n.

    To get some practice, try these examples, and examine the resulting
    testfile.pl.tdy file:

     perltidy -i=8 testfile.pl

    This changes the default of 4 spaces per indentation level to be 8. Now
    just to emphasize the point, try this and examine the result:

     perltidy -i=0 testfile.pl

    There will be no indentation at all in this case.

    This is a good place to mention a few points regarding the input flags.
    First, for each option, there are two forms, a long form and a short
    form, and either may be used.

    For example, if you want to change the number of columns corresponding
    to one indentation level to 3 (from the default of 4) you may use either

     -i=3   or  --indent-columns=3

    The short forms are convenient for entering parameters by hand, whereas
    the long forms, though often ridiculously long, are self-documenting and
    therefore useful in configuration scripts. You may use either one or two
    dashes ahead of the parameters. Also, the '=' sign is optional, and may
    be a single space instead. However, the value of a parameter must NOT be
    adjacent to the flag, like this -i3 B(WRONG). Also, flags must be input
    separately, never bundled together.

  Tabs or Spaces?
    With indentation, there is always a tab issue to resolve. By default,
    perltidy will use leading ascii space characters instead of tabs. The
    reason is that this will be displayed correctly by virtually all
    editors, and in the long run, will avoid maintenance problems. However,
    if you prefer, you may have perltidy entab the leading whitespace of a
    line with the command -et=n, where n is the number of spaces which will
    be represented by one tab.

  Line Length and Continuation Indentation.
    TBD: -l, -ci

  Input/Output Control
    For safety, perltidy never changes the input file, and instead always
    writes its output to a new file. Its default behavior is to just create
    an output filename by appending an extension, .tdy, to whatever filename
    it is given. On most systems, you may use wildcards to reformat a whole
    batch of files at once, like this for example:

     perltidy *.pl

    and in this case, each of the output files will be have a name equal to
    the input file with the extension .tdy appended.

    If there is no input filename specified on the command line, then input
    is assumed to come from standard input and output will go to standard
    output. So you can use perltidy as a filter, like this:

     perltidy <somefile.pl >newfile.pl

    If you are executing perltidy on a file and want to force the output to
    standard output, rather than create a .tdy file, you can indicate this
    with the flag -st, like this:

     perltidy somefile.pl -st >otherfile.pl

    You can also control the name of the output file with the -o flag, like
    this:

     perltidy testfile.pl -o=testfile.new.pl

  Making Backups
    In an actual project, at this point you could make a backup copy of the
    original script and then rename testfile.pl.tdy to be testfile.pl. While
    Perltidy is a very reliable program, it is very important to have a
    standard procedure for backing up your script in case something goes
    wrong. For a small project, a simple backup procedure using RCS could be
    as follows (see the rcsintro(1) man page).

            ci -l testfile.pl
            perltidy testfile.pl

    A good practice is to use a file comparison utility, such as diff, to
    examine the differences between the original and reformatted files.
    Then, if no problems are seen, update to the new version using

            mv testfile.pl testfile.pl.bak
            mv testfile.pl.tdy testfile.pl

    This has the effect of keeping a historical record of the script in the
    RCS directory, and a current separate backup as testfile.pl.bak. Of
    course, you should make regular additional backups to other media as
    well.

  Style Variations
    Perltidy has to make some kind of default selection of formatting
    options, and its choice is to try to follow the suggestions in the
    perlstyle man pages. Many programmers more or less follow these
    suggestions with a few exceptions. The parameters most commonly used
    include these:

    -ce, cuddled elses
        If you prefer cuddled elses, use the -ce flag.

    -bl, braces left
        Here is what the "if" block in the above script looks like with -bl:

                if ( $temperature > 75 )
                {
                    print "Too hot!\n";
                }
                elsif ( $temperature < 68 )
                {
                    print "Too cold!\n";
                }
                else
                {
                    print "Just right!\n";
                }

    -lp, Lining up with parentheses
        Consider:

                %romanNumerals = (
                    one   => 'I',
                    two   => 'II',
                    three => 'III',
                    four  => 'IV',
                    five  => 'V',
                    six   => 'VI',
                    seven => 'VII',
                    eight => 'VIII',
                    nine  => 'IX',
                    ten   => 'X'
                );

        With the -lp flag, this is formatted as:

                %romanNumerals = (
                                   one   => 'I',
                                   two   => 'II',
                                   three => 'III',
                                   four  => 'IV',
                                   five  => 'V',
                                   six   => 'VI',
                                   seven => 'VII',
                                   eight => 'VIII',
                                   nine  => 'IX',
                                   ten   => 'X'
                                   );

        which is probably easier to read.

    -bt,-pt,-sbt: Container tightness
        (TBD)

  Configuration Files
    While style preferences vary, most people would agree that it is
    important to maintain a uniform style within a script, and this is a
    major benefit provided by perltidy. Once you have decided on which, if
    any, special options you prefer, you may want to avoid having to enter
    them each time you run it. You can do this by creating a special file
    named .perltidyrc in either your home directory, your current directory,
    or certain system-dependent locations. (Note the leading "." in the file
    name).

    A handy command to know when you start using a configuration file is

      perltidy -dpro

    which will dump to standard output the search that perltidy makes when
    looking for a configuration file, and the contents of the one that it
    selects, if any. This is one of a number of useful "dump and die"
    commands, in which perltidy will dump some information to standard
    output and then immediately exit. Others include -h, which dumps help
    information, and -v, which dumps the version number.

    Another useful command when working with configuration files is

     perltidy -pro=file

    which causes the contents of file to be used as the configuration file
    instead of a .perltidyrc file. With this command, you can easily switch
    among several different candidate configuration files during testing.

    This .perltidyrc file is free format. It is simply a list of parameters,
    just as they would be entered on a command line. Any number of lines may
    be used, with any number of parameters per line, although it may be
    easiest to read with one parameter per line. Blank lines are ignored,
    and text after a '#' is ignored to the end of a line.

    Here is an example of a .perltidyrc file:

      # This is a simple of a .perltidyrc configuration file
      # This implements a highly spaced style
      -bl    # braces on new lines
      -pt=0  # parens not tight at all
      -bt=0  # braces not tight
      -sbt=0 # square brackets not tight

    If you experiment with this file, remember that it is in your directory,
    since if you are running on a Unix system, files beginning with a "."
    are normally hidden.

    If you have a .perltidyrc file, and want perltidy to ignore it, use the
    -npro flag on the command line.

  Error Reporting
    To see how perltidy reports errors , try introducing an extra opening
    brace somewhere in a test file. For example, introducing an extra brace
    in the file listed above produces the following message on the terminal
    (or standard error output):

     Please see file testfile.pl.ERR!

    Here is what testfile.pl.ERR contains:

     10:    final indentation level: 1
 
     Final nesting depth of '{'s is 1
     The most recent un-matched '{' is on line 6
     6: } elsif ($temperature < 68) {{
                                    ^

    This shows how Perltidy will, by default, write error messages to a file
    with the extension .ERR, and it will write a note that it did so to the
    standard error device. If you would prefer to have the error messages
    sent to standard output, instead of to a .ERR file, use the -se flag.

    Almost every programmer would want to see error messages of this type,
    but there are a number of messages which, if reported, would be
    annoying. To manage this problem, Perltidy puts its messages into two
    categories: errors and warnings. The default is to just report the
    errors, but you can control this with input flags, as follows:

     flag  what this does
     ----  --------------
           default: report errors but not warnings
     -w    report all errors and warnings
     -q    do not report either errors or warnings

    The default is generally a good choice, but if you are trying to locate
    a bug, you might find the -w flag useful.

  Syntax Checking
    Perltidy will normally try to check itself by running "perl -c" on both
    the input and output files. If the input file has good syntax but the
    output file has bad syntax, then perltidy made an error. This is very
    unlikely, but worth checking.

    If the input file has an error according to the "perl -c" check, then
    the output file will not be checked. In this event, the error message
    returned by the "perl -c" check will be discarded by default, but it
    will be included in the error output file if the -w flag is given. The
    reason for discarding the message by default is that "perl -c" can
    produce annoying messages when Perltidy is formatting snippets of code
    rather than complete scripts.

    This syntax check has been deactivated for Windows 9x/Me because of
    robustness problems with these systems. Perltidy will, of course, still
    report any syntax errors that it detects by itself on these systems.

  The Log File
    One last topic that needs to be touched upon concerns the .LOG file.
    This is where perltidy writes messages that are not normally of any
    interest, but which just might occasionally be useful. This file is not
    saved, though, unless there is an error or you ask for it to be saved.

    There are a couple of ways to ask perltidy to save a log file. To create
    a relatively sparce log file, use

     perltidy -log testfile.pl

    and for a verbose log file, use

     perltidy -g testfile.pl

    The difference is that the first form only saves detailed information at
    least every 50th line, while the second form saves detailed information
    about every line.

    So returning to our example, lets force perltidy to save a verbose log
    file by issuing the following command

     perltidy -g testfile.pl

    You will find that a file named testfile.pl.LOG has been created in your
    directory.

    If you open this file, you will see that it is a text file with a
    combination of warning messages and informative messages. All you need
    to know for now is that it exists.

  Using Perltidy as a Filter on Selected Text from an Editor
    Most programmer's editors allow a selected group of lines to be passed
    through an external filter. Perltidy has been designed to work well as a
    filter, and it is well worthwhile learning the appropriate commands to
    do this with your editor. You may want to supply the -q flag to prevent
    error messages regarding incorrect syntax, since errors may be obvious
    in the indentation of the reformatted text. If you do not use the -q
    flag, you will need to use the undo keys in case an error message
    appears on the screen.

    For example, within the vim editor it is only necessary to select the
    text by any of the text selection methods, and then issue the command
    !perltidy in command mode. Thus, an entire file can be formatted using

     :%!perltidy -q

    It isn't necessary to format an entire file, however. Perltidy will
    probably work well provided that you select blocks of text whose braces,
    parentheses, and square brackets are properly balanced.

  Writing an HTML File
    Perltidy can switch between two different output modes. We have been
    discussing what might be called its "beautifier" mode, but it can also
    output in HTML. To do this, use the -html flag, like this:

     perltidy -html testfile.pl

    which will produce a file testfile.pl.html. There are many parameters
    available for adjusting the appearance of an HTML file, but a very easy
    way is to just write the HTML file with this simple command and then
    edit the stylesheet which is embedded at its top.

    One important thing to know about the -html flag is that Perltidy can
    either send its output to its beautifier or to its HTML writer, but not
    both in a single run. So the situation can be represented like this:

                      ------------
                      |          |     --->beautifier--> testfile.pl.tdy
     testfile.pl -->  | perltidy | -->
                      |          |     --->HTML -------> testfile.pl.html
                      ------------

    And in the future, there may be more output selections. So if you would
    like to both beautify a script and write it to HTML, you need to do it
    in two steps.

  Summary
    That's enough to get started using perltidy. You will want to delete
    unwanted files in the temporary directory created in this tutorial. Many
    additional special features and capabilities can be found in the manual
    pages for perltidy.

    We hope that perltidy makes perl programming a little more fun. Please
    check the perltidy web site <http://perltidy.sourceforge.net>
    occasionally for updates.

