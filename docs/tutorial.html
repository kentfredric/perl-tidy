<HTML>
<HEAD>
<TITLE>A Brief Perltidy Tutorial</TITLE>
<LINK REV="made" HREF="mailto:perl@packages.debian.org">
</HEAD>

<BODY>

<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#a brief perltidy tutorial">A Brief Perltidy Tutorial</A></LI>
	<UL>

		<LI><A HREF="#a first test">A First Test</A></LI>
		<LI><A HREF="#indentation">Indentation</A></LI>
		<LI><A HREF="#input flags">Input Flags</A></LI>
		<LI><A HREF="#line length and continuation indentation.">Line Length and Continuation Indentation.</A></LI>
		<LI><A HREF="#tabs or spaces">Tabs or Spaces?</A></LI>
		<LI><A HREF="#input/output control">Input/Output Control</A></LI>
		<LI><A HREF="#making backups">Making Backups</A></LI>
		<LI><A HREF="#style variations">Style Variations</A></LI>
		<LI><A HREF="#configuration files">Configuration Files</A></LI>
		<LI><A HREF="#error reporting">Error Reporting</A></LI>
		<LI><A HREF="#syntax checking">Syntax Checking</A></LI>
		<LI><A HREF="#the log file">The Log File</A></LI>
		<LI><A HREF="#using perltidy as a filter on selected text from an editor">Using Perltidy as a Filter on Selected Text from an Editor</A></LI>
		<LI><A HREF="#writing an html file">Writing an HTML File</A></LI>
		<LI><A HREF="#summary">Summary</A></LI>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="a brief perltidy tutorial">A Brief Perltidy Tutorial</A></H1>
<P>Perltidy can save you a lot of tedious editing if you spend a few
minutes learning to use it effectively.  Perltidy is highly
configurable, but for many programmers the default parameter set will be
satisfactory, with perhaps a few additional parameters to account for
style preferences.</P>
<P>This tutorial assumes that perltidy has been installed on your system.
Installation instructions accompany the package.  To follow along with
this tutorial, please find a small Perl script and place a copy in a
temporary directory.  For example, here is a small (and silly) script:</P>
<PRE>
 print &quot;Help Desk -- What Editor do you use?&quot;;
 chomp($editor = &lt;STDIN&gt;);
 if ($editor =~ /emacs/i) {
   print &quot;Why aren't you using vi?\n&quot;;
 } elsif ($editor =~ /vi/i) {
   print &quot;Why aren't you using emacs?\n&quot;;
 } else {
   print &quot;I think that's the problem\n&quot;;
 }</PRE>
<P>It is included in the <EM>docs</EM> section of the distribution.</P>
<P>
<H2><A NAME="a first test">A First Test</A></H2>
<P>Assume that the name of your script is <EM>testfile.pl</EM>.  You can reformat it
with the default options to use the style recommended in the perlstyle man
pages with the command:</P>
<PRE>
 perltidy testfile.pl</PRE>
<P>For safety, perltidy never overwrites your original file.  In this case,
its output will go to a file named <EM>testfile.pl.tdy</EM>, which you should
examine now with your editor.  Here is what the above file looks like
with the default options:</P>
<PRE>
 print &quot;Help Desk -- What Editor do you use?&quot;;
 chomp( $editor = &lt;STDIN&gt; );
 if ( $editor =~ /emacs/i ) {
     print &quot;Why aren't you using vi?\n&quot;;
 }
 elsif ( $editor =~ /vi/i ) {
     print &quot;Why aren't you using emacs?\n&quot;;
 }
 else {
     print &quot;I think that's the problem\n&quot;;
 }</PRE>
<P>You'll notice an immediate style change from the ``cuddled-else'' style of
the original to the default ``non-cuddled-else'' style.  This is because
perltidy has to make some kind of default selection of formatting
options, and this default tries to follow the suggestions in the
perlstyle man pages.</P>
<P>If you prefer the original ``cuddled-else'' style you can indicate that
with a <STRONG>-ce</STRONG> flag.  So if you rerun with that flag</P>
<PRE>
 perltidy -ce testfile.pl</PRE>
<P>you will see a return to the original ``cuddled-else'' style.  There are
many more parameters for controlling style, and some of the most useful
of these are discussed below.</P>
<P>
<H2><A NAME="indentation">Indentation</A></H2>
<P>Another noticeable difference between the original and the reformatted
file is that the indentation has been changed from 2 spaces to 4 spaces.
That's because 4 spaces is the default.  You may change this to be a
different number with <STRONG>-i=n</STRONG>.</P>
<P>To get some practice, try these examples, and examine the resulting
<EM>testfile.pl.tdy</EM> file:</P>
<PRE>
 perltidy -i=8 testfile.pl</PRE>
<P>This changes the default of 4 spaces per indentation level to be 8.  Now
just to emphasize the point, try this and examine the result:</P>
<PRE>
 perltidy -i=0 testfile.pl</PRE>
<P>There will be no indentation at all in this case.</P>
<P>
<H2><A NAME="input flags">Input Flags</A></H2>
<P>This is a good place to mention a few points regarding the input flags.
First, for each option, there are two forms, a long form and a short
form, and either may be used.</P>
<P>For example, if you want to change the number of columns corresponding to one
indentation level to 3 (from the default of 4) you may use either</P>
<PRE>
 -i=3   or  --indent-columns=3</PRE>
<P>The short forms are convenient for entering parameters by hand, whereas
the long forms, though often ridiculously long, are self-documenting and
therefore useful in configuration scripts.  You may use either one or
two dashes ahead of the parameters.  Also, the '=' sign is optional, 
and may be a single space instead.  However, the value of a parameter
must NOT be adjacent to the flag, like this <STRONG>-i3</STRONG> B(WRONG).  Also,
flags must be input separately, never bundled together.</P>
<P>
<H2><A NAME="line length and continuation indentation.">Line Length and Continuation Indentation.</A></H2>
<P>If you change the indentation spaces you will probably also need to
change the continuation indentation spaces with the parameter <STRONG>-ci=n</STRONG>.
The continuation indentation is the extra indentation -- 2 spaces by
default -- given to that portion of a long line which has been placed
below the start of a statement.  For example:</P>
<PRE>
 croak &quot;Couldn't pop genome file&quot;
   unless sysread( $impl-&gt;{file}, $element, $impl-&gt;{group} )
   and truncate( $impl-&gt;{file}, $new_end );</PRE>
<P>There is no fixed rule for setting the value for <STRONG>-ci=n</STRONG>, but it should
probably not exceed one-half of the number of spaces of a full
indentation level.</P>
<P>In the above snippet, the statement was broken into three lines.  The
actual number is governed by a parameter, the maximum line length, as
well as by what perltidy considers to be good break points.  The maximum
line length is 80 characters by default.  You can change this to be any
number <STRONG>n</STRONG> with the <STRONG>-l=n</STRONG> flag.  Perltidy tries to produce lines
which do not exceed this length, and it does this by finding good break
points.  For example, the above snippet would look like this with
<STRONG>perltidy -l=40</STRONG>:</P>
<PRE>
 croak &quot;Couldn't pop genome file&quot;
   unless sysread(
     $impl-&gt;{file}, $element,
     $impl-&gt;{group}
   )
   and truncate( $impl-&gt;{file},
     $new_end );</PRE>
<P>
<H2><A NAME="tabs or spaces">Tabs or Spaces?</A></H2>
<P>With indentation, there is always a tab issue to resolve.  By default,
perltidy will use leading ascii space characters instead of tabs.  The
reason is that this will be displayed correctly by virtually all
editors, and in the long run, will avoid maintenance problems.</P>
<P>However, if you prefer, you may have perltidy entab the leading
whitespace of a line with the command <STRONG>-et=n</STRONG>, where <STRONG>n</STRONG> is the number
of spaces which will be represented by one tab.  But note that your text
will not be displayed properly unless viewed with software that is
configured to display <STRONG>n</STRONG> spaces per tab.</P>
<P>
<H2><A NAME="input/output control">Input/Output Control</A></H2>
<P>In the first example, we saw that if we pass perltidy the name
of a file on the command line, it reformats it and creates a
new filename by appending an extension, <EM>.tdy</EM>.  This is the
default behavior, but there are several other options.</P>
<P>On most systems, you may use wildcards to reformat a whole batch of
files at once, like this for example:</P>
<PRE>
 perltidy *.pl</PRE>
<P>and in this case, each of the output files will be have a name equal to
the input file with the extension <EM>.tdy</EM> appended.</P>
<P>If there is no input filename specified on the command line, then input
is assumed to come from standard input and output will go to standard
output.  On systems with a Unix-like interface, you can use perltidy as
a filter, like this:</P>
<PRE>
 perltidy &lt;somefile.pl &gt;newfile.pl</PRE>
<P>What happens in this case is that the shell takes care of the redirected
input files, '&lt;somefile.pl', and so perltidy never sees the filename.
Therefore, it knows to use the standard input and standard output
channels.</P>
<P>If you are executing perltidy on a file and want to force the output
to standard output, rather than create a <EM>.tdy</EM> file, you can
indicate this with the flag <STRONG>-st</STRONG>, like this:</P>
<PRE>
 perltidy somefile.pl -st &gt;otherfile.pl</PRE>
<P>You can also control the name of the output file with the <STRONG>-o</STRONG> flag,
like this:</P>
<PRE>
 perltidy testfile.pl -o=testfile.new.pl</PRE>
<P>One thing that you cannot do with perltidy is to reformat a script
and overwrite the original version.  This is a safety precaution.</P>
<P>
<H2><A NAME="making backups">Making Backups</A></H2>
<P>In an actual project, you will need to make a backup copy of the
original script and then rename <EM>testfile.pl.tdy</EM> to be <EM>testfile.pl</EM>.
While perltidy is a very reliable program, it is very important to have
a standard procedure for backing up your script in case something goes
wrong.  For a small project, a simple backup procedure using RCS could
be as follows (see the <CODE>rcsintro(1)</CODE> man page).</P>
<PRE>
        ci -l testfile.pl
        perltidy testfile.pl</PRE>
<P>A good practice is to use a file comparison utility, such as diff, to 
examine the differences between the original and reformatted files.
Then, if no problems are seen, update to the new version using</P>
<PRE>
        mv testfile.pl testfile.pl.bak
        mv testfile.pl.tdy testfile.pl</PRE>
<P>This has the effect of keeping a historical record of the script in the
RCS directory, and a current separate backup as <EM>testfile.pl.bak</EM>.  Of
course, you should make regular additional backups to other media as
well.</P>
<P>Please do not fall into this trap:  Let's say you are working on a
complex script, and run it through perltidy.  You open the reformatted
script with your editor, and are so pleased to see it cleaned up that
you immediately continue editing it.  If you forget that you are editing
a <EM>.tdy</EM> file, your work will be lost if you inadvertently run perltidy
again on the original script.  To avoid this, you need to rename your
files before starting to work again.</P>
<P>
<H2><A NAME="style variations">Style Variations</A></H2>
<P>Perltidy has to make some kind of default selection of formatting
options, and its choice is to try to follow the suggestions in the
perlstyle man pages.  Many programmers more or less follow these
suggestions with a few exceptions.  The parameters most commonly
used include these:</P>
<DL>
<DT><STRONG><A NAME="item_%2Dce%2C_cuddled_elses"><STRONG>-ce</STRONG>, cuddled elses</A></STRONG><BR>
<DD>
If you prefer cuddled elses, use the <STRONG>-ce</STRONG> flag.
<P></P>
<DT><STRONG><A NAME="item_%2Dbl%2C_braces_left"><STRONG>-bl</STRONG>, braces left</A></STRONG><BR>
<DD>
Here is what the <CODE>if</CODE> block in the above script looks like with <STRONG>-bl</STRONG>:
<PRE>
 if ( $editor =~ /emacs/i )
 {
     print &quot;Why aren't you using vi?\n&quot;;
 }
 elsif ( $editor =~ /vi/i )
 {
     print &quot;Why aren't you using emacs?\n&quot;;
 }
 else
 {
     print &quot;I think that's the problem\n&quot;;
 }</PRE>
<P></P>
<DT><STRONG><A NAME="item_%2Dlp%2C_Lining_up_with_parentheses"><STRONG>-lp</STRONG>, Lining up with parentheses</A></STRONG><BR>
<DD>
The <STRONG>-lp</STRONG> parameter can enhance the readability of lists by adding
extra indentation.  Consider:
<PRE>
        %romanNumerals = (
            one   =&gt; 'I',
            two   =&gt; 'II',
            three =&gt; 'III',
            four  =&gt; 'IV',
            five  =&gt; 'V',
            six   =&gt; 'VI',
            seven =&gt; 'VII',
            eight =&gt; 'VIII',
            nine  =&gt; 'IX',
            ten   =&gt; 'X'
        );</PRE>
<P>With the <STRONG>-lp</STRONG> flag, this is formatted as:</P>
<PRE>
        %romanNumerals = (
                           one   =&gt; 'I',
                           two   =&gt; 'II',
                           three =&gt; 'III',
                           four  =&gt; 'IV',
                           five  =&gt; 'V',
                           six   =&gt; 'VI',
                           seven =&gt; 'VII',
                           eight =&gt; 'VIII',
                           nine  =&gt; 'IX',
                           ten   =&gt; 'X'
                           );</PRE>
<P>which is probably easier to read.</P>
<P></P>
<DT><STRONG><A NAME="item_%2Dbt%2C%2Dpt%2C%2Dsbt%3A_Container_tightness"><STRONG>-bt</STRONG>,<STRONG>-pt</STRONG>,<STRONG>-sbt</STRONG>:  Container tightness</A></STRONG><BR>
<DD>
These are parameters for controlling the amount of space within
containing parentheses, braces, and square brackets.  The example below
shows the effect of the three possible values, 0, 1, and 2, for the case
of parentheses:
<PRE>
 if ( ( my $len_tab = length( $tabstr ) ) &gt; 0 ) {  # -pt=0
 if ( ( my $len_tab = length($tabstr) ) &gt; 0 ) {    # -pt=1 (default)
 if ((my $len_tab = length($tabstr)) &gt; 0) {        # -pt=2</PRE>
<P>A value of 0 causes all parens to be padded on the inside with a space,
and a value of 2 causes this never to happen.  With a value of 1, spaces
will be introduced if the item within is more than a single token.</P>
<P></P></DL>
<P>
<H2><A NAME="configuration files">Configuration Files</A></H2>
<P>While style preferences vary, most people would agree that it is
important to maintain a uniform style within a script, and this is a
major benefit provided by perltidy.  Once you have decided on which, if
any, special options you prefer, you may want to avoid having to enter
them each time you run it.  You can do this by creating a special file
named <EM>.perltidyrc</EM> in either your home directory, your current
directory, or certain system-dependent locations.  (Note the leading ``.''
in the file name).</P>
<P>A handy command to know when you start using a configuration file is</P>
<PRE>
  perltidy -dpro</PRE>
<P>which will dump to standard output the search that perltidy makes when
looking for a configuration file, and the contents of the one that it
selects, if any.  This is one of a number of useful ``dump and die''
commands, in which perltidy will dump some information to standard
output and then immediately exit.  Others include <STRONG>-h</STRONG>, which dumps
help information, and <STRONG>-v</STRONG>, which dumps the version number.</P>
<P>Another useful command when working with configuration files is</P>
<PRE>
 perltidy -pro=file</PRE>
<P>which causes the contents of <EM>file</EM> to be used as the configuration
file instead of a <EM>.perltidyrc</EM> file.  With this command, you can
easily switch among several different candidate configuration files
during testing.</P>
<P>This <EM>.perltidyrc</EM> file is free format.  It is simply a list of
parameters, just as they would be entered on a command line.  Any number
of lines may be used, with any number of parameters per line, although
it may be easiest to read with one parameter per line.  Blank lines are
ignored, and text after a '#' is ignored to the end of a line.</P>
<P>Here is an example of a <EM>.perltidyrc</EM> file:</P>
<PRE>
  # This is a simple of a .perltidyrc configuration file
  # This implements a highly spaced style
  -bl    # braces on new lines
  -pt=0  # parens not tight at all
  -bt=0  # braces not tight
  -sbt=0 # square brackets not tight</PRE>
<P>If you experiment with this file, remember that it is in your directory,
since if you are running on a Unix system, files beginning with a ``.''
are normally hidden.</P>
<P>If you have a <EM>.perltidyrc</EM> file, and want perltidy to ignore it,
use the <STRONG>-npro</STRONG> flag on the command line.</P>
<P>
<H2><A NAME="error reporting">Error Reporting</A></H2>
<P>Let's perform a fire drill to see how perltidy reports errors.  Try
introducing an extra opening brace somewhere in a test file.  For
example, introducing an extra brace in the file listed above produces
the following message on the terminal (or standard error output):</P>
<PRE>
 Please see file testfile.pl.ERR!</PRE>
<P>Here is what <EM>testfile.pl.ERR</EM> contains:</P>
<PRE>
 10:    final indentation level: 1
</PRE>
<PRE>

 Final nesting depth of '{'s is 1
 The most recent un-matched '{' is on line 6
 6: } elsif ($temperature &lt; 68) {{
                                ^</PRE>
<P>This shows how perltidy will, by default, write error messages to a file
with the extension <EM>.ERR</EM>, and it will write a note that it did so to
the standard error device.  If you would prefer to have the error
messages sent to standard output, instead of to a <EM>.ERR</EM> file, use the
<STRONG>-se</STRONG> flag.</P>
<P>Almost every programmer would want to see error messages of this type,
but there are a number of messages which, if reported, would be
annoying.  To manage this problem, perltidy puts its messages into two
categories: errors and warnings.  The default is to just report the
errors, but you can control this with input flags, as follows:</P>
<PRE>
 flag  what this does
 ----  --------------
       default: report errors but not warnings
 -w    report all errors and warnings
 -q    do not report either errors or warnings</PRE>
<P>The default is generally a good choice, but if you are trying to
locate a bug, you might find the <STRONG>-w</STRONG> flag useful.</P>
<P>
<H2><A NAME="syntax checking">Syntax Checking</A></H2>
<P>Perltidy will normally try to check itself by running <CODE>perl -c</CODE> on both
the input and output files.  If the input file has good syntax but the
output file has bad syntax, then perltidy made an error.  This is very
unlikely, but worth checking.</P>
<P>If the input file has an error according to the <CODE>perl -c</CODE> check, then
the output file will not be checked, and any error messages returned by
the <CODE>perl -c</CODE> check will be discarded (because they usually turn out to
be more annoying than helpful).  If you want to see them, though, you
can use the <STRONG>-w</STRONG> flag.  This might be useful if you are debugging a
script.</P>
<P>Here's a diagram showing how this works:</P>
<PRE>
                          OK                            OK
     check input file ----------&gt;  check output file ---------&gt; ok
             |                            |
             | Fail                       | Fail
             |                            |
       -w shows errors             perltidy made error</PRE>
<P>This syntax check will be deactivated for Windows 9x/Me and also when
input or output are not from identifiable filenames.  Perltidy will, of
course, still report any syntax errors that it detects by itself in
these cases.</P>
<P>
<H2><A NAME="the log file">The Log File</A></H2>
<P>One last topic that needs to be touched upon concerns the <EM>.LOG</EM> file.
This is where perltidy records messages that are not normally of any
interest, but which just might occasionally be useful.  This file is not
saved, though, unless perltidy detects that it has made a mistake or you
ask for it to be saved.</P>
<P>There are a couple of ways to ask perltidy to save a log file.  To
create a relatively sparse log file, use</P>
<PRE>
 perltidy -log testfile.pl</PRE>
<P>and for a verbose log file, use</P>
<PRE>
 perltidy -g testfile.pl</PRE>
<P>The difference is that the first form only saves detailed information at
least every 50th line, while the second form saves detailed information
about every line.</P>
<P>So returning to our example, lets force perltidy to save a
verbose log file by issuing the following command</P>
<PRE>
 perltidy -g testfile.pl</PRE>
<P>You will find that a file named <EM>testfile.pl.LOG</EM> has been
created in your directory.</P>
<P>If you open this file, you will see that it is a text file with a
combination of warning messages and informative messages.  All you need
to know for now is that it exists.</P>
<P>
<H2><A NAME="using perltidy as a filter on selected text from an editor">Using Perltidy as a Filter on Selected Text from an Editor</A></H2>
<P>Most programmer's editors allow a selected group of lines to be passed
through an external filter.  Perltidy has been designed to work well as
a filter, and it is well worthwhile learning the appropriate commands to
do this with your editor.  This means that you can enter a few
keystrokes and watch a block of text get reformatted.  If you are not
doing this, you are missing out of a lot of fun!  You may want to supply
the <STRONG>-q</STRONG> flag to prevent error messages regarding incorrect syntax,
since errors may be obvious in the indentation of the reformatted text.
This is entirely optional, but if you do not use the <STRONG>-q</STRONG> flag, you
will need to use the undo keys in case an error message appears on the
screen.</P>
<P>For example, within the <STRONG>vim</STRONG> editor it is only necessary to select the
text by any of the text selection methods, and then issue the command
!perltidy in command mode.  Thus, an entire file can be formatted using</P>
<PRE>
 :%!perltidy -q</PRE>
<P>It isn't necessary to format an entire file, however.  Perltidy will
probably work well as long as you select blocks of text whose braces,
parentheses, and square brackets are properly balanced.</P>
<P>
<H2><A NAME="writing an html file">Writing an HTML File</A></H2>
<P>Perltidy can switch between two different output modes.  We have been
discussing what might be called its ``beautifier'' mode, but it can also
output in HTML.  To do this, use the <STRONG>-html</STRONG> flag, like this:</P>
<PRE>
 perltidy -html testfile.pl</PRE>
<P>which will produce a file <EM>testfile.pl.html</EM>.  There are many
parameters available for adjusting the appearance of an HTML file, but a
very easy way is to just write the HTML file with this simple command
and then edit the stylesheet which is embedded at its top.</P>
<P>One important thing to know about the <STRONG>-html</STRONG> flag is that perltidy can
either send its output to its beautifier or to its HTML writer, but not
both in a single run.  So the situation can be represented like this:</P>
<PRE>
                  ------------
                  |          |     ---&gt;beautifier--&gt; testfile.pl.tdy
 testfile.pl --&gt;  | perltidy | --&gt;
                  |          |     ---&gt;HTML -------&gt; testfile.pl.html
                  ------------</PRE>
<P>And in the future, there may be more output filters.  So if you would
like to both beautify a script and write it to HTML, you need to do it
in two steps.</P>
<P>
<H2><A NAME="summary">Summary</A></H2>
<P>That's enough to get started using perltidy.  You will want to delete
unwanted files in the temporary directory created in this tutorial.
Many additional special features and capabilities can be found in the
manual pages for perltidy.</P>
<P>We hope that perltidy makes perl programming a little more fun.
Please check the perltidy
web site <A HREF="http://perltidy.sourceforge.net">http://perltidy.sourceforge.net</A> occasionally
for updates.</P>

</BODY>

</HTML>
