# OLD: Had strange alignment of eq here
ref($self)                    eq ref($other) &&                 # same class
  $self->canonical->as_string eq $other->canonical->as_string;

# do not align these braces
foreach ( @{$routput_array} ) { $fh->print($_) }
eval                          { $fh->close() };

# set_vertical_alignment_markers does not make opening parens
# an alignment token here:
$code =
    ( $case_matters ? $accessor    : " lc($accessor) " )
  . ( $yesno        ? " eq "       : " ne " )
  . ( $case_matters ? " q{$text} " : "q{\L$text}\E " );
# -pvt=2   -pvtc=2
if ( ( !( $from || $to || $subject || $size || ( $fieldname && $fieldval ) ) || !$ruletype ) &&
     !$dest ) {
    next;
}
( $x1, $y1, $x2, $y2 ) = ( &$transpose( @{ $s->coord_as_list($i) } ), &$transpose( @{ $s->coord_as_list( $i + 1 ) } ) );
{
    {
        my ( $pre, $post ) = @{
            {   "pp_anonlist" => [ "[", "]" ],
                "pp_anonhash" => [ "{", "}" ] }->{ $kid->ppaddr } };

        # do not pad: the && line is not balanced
        if ( ( $day > 30 ) && ( ( $month == 4 ) || ( $month == 6 ) || ( $month == 9 ) || ( $month == 11 ) ) ) { }
    }
}
debug( "Connecting to DB.", "Extra-Parameters: " . join( "<->", $extra_parms ), "Config: " . join( "<->", %config ) );
local (@a) = ( split( /$pathsep/o, $ENV{'P_SGML_PATH'} ), split( /$pathsep/o, $ENV{'SGML_SEARCH_PATH'} ) );

/^Number Of Independent Variables=(\d+)/i                      &&
    ( $1 > 1 )                                                 &&
    ( print STDERR "\nMore than 1 independent variable!\n\n" ) &&
    exit;

# align opening parens
if ( ( index( $msg_line_lc, $nick1 ) != -1 ) ||
     ( index( $msg_line_lc, $nick2 ) != -1 ) ||
     ( index( $msg_line_lc, $nick3 ) != -1 ) ) {
    do_something();
}

return ( /^#!\s+\/bin\/nawk/ ||
         /^#!\s+\/usr\/bin\/nawk/        ||
         /^#!\s+\/usr\/local\/bin\/nawk/ ||
         /^#!\s+\/bin\/gawk/             ||
         /^#!\s+\/usr\/bin\/gawk/        ||
         /^#!\s+\/usr\/local\/bin\/gawk/ ||
         /^#!\s+\/bin\/awk/              ||
         /^#!\s+\/usr\/bin\/awk/         ||
         /^BEGIN\s+/ );

# good alignment tests
if ( $ARGV[0] eq "--v" ||
     $ARGV[0] eq "--ve"     ||
     $ARGV[0] eq "--ver"    ||
     $ARGV[0] eq "--vers"   ||
     $ARGV[0] eq "--versi"  ||
     $ARGV[0] eq "--versio" ||
     $ARGV[0] eq "--version" ) {
}

$a = $ARGV[0] eq "--v" || $ARGV[0] eq "--ve" || $ARGV[0] eq "--ver";

if ( /^-[CUuaEhRrz]$/ ||
     /^-I[24]$/        ||
     /^-onetrip$/      ||
     /^-![clPR]$/      ||
     /^-ext$/          ||
     /^-!bs$/          ||
     /^-W[1-9][0-9]*$/ ||
     /^-w8$/           ||
     /^-w66$/          ||
     /^-r8$/           ||
     /^-N[^n][0-9]+$/ ) {
}

elsif ( $_ eq 'no-installman' ||
        $_ eq 'no-installinfo' ||
        $_ eq 'dist-shar'      ||
        $_ eq 'dist-zip'       ||
        $_ eq 'dist-tarZ'      ||
        $_ eq 'dejagnu'        ||
        $_ eq 'no-texinfo.tex' ||
        $_ eq 'readme-alpha'   ||
        $_ eq 'check-news' ) {
}

my @category = ( 'radweg'    => [ 'RW0', 'Radweg',              'Radwege' ],
                 'pflicht'   => [ 'RW1', 'benutzungspflichtig', 'benutzungspflichtige Radwege' ],
                 'suggestiv' => [ 'RW2', 'Suggestivstreifen' ], # wird nicht verwendet
                 'spur'      => [ 'RW3', 'Radstreifen' ],
                 'bus'       => [ 'RW4', 'Busspur',             'Busspuren' ],
                 'ruhig'     => [ 'RW5', 'verkehrsberuhigt' ],
                 'radstr'    => [ 'RW6', 'Fahrradstraße',       'Fahrradstraßen' ],
                 'kein'      => [ undef, 'kein Radweg',         'keine Radwege' ], );

# align for
$priv{$_}{16}  = "INBIN"  for ( "open", "backtick" );
$priv{$_}{32}  = "INCR"   for ( "open", "backtick" );
$priv{$_}{64}  = "OUTBIN" for ( "open", "backtick" );
$priv{$_}{128} = "OUTCR"  for ( "open", "backtick" );

# align 'while'
$nglyphbits++   while ( $nglyphmax >=   ( 1 << $nglyphbits ) );
$nadvancebits++ while ( $nadvancemax >= ( 1 << $nadvancebits ) );

# at present, 'last' remains aligned across a gap:
/s/  && do { $msg->subject($arg); last SWITCH; };
/q/  && do { return; };
/\!/ && do { system($arg);        last SWITCH; };

# good test line:
die sprintf( "Usage: %s [ -r | -a | -f fmt ] file ...\n", ( $0 =~ m|.*/(.*)|o ) )
    if ( $opt_h     ||
         ( !@ARGV ) ||
         ( ( $opt_a && $opt_r ) ||
           ( $opt_a && $opt_f ) ||
           ( $opt_r && $opt_f ) ) );
if ( abs($offhour) >= 24 ) {
    die("822-date: local time offset greater than or equal to 24 hours\n");
}

# From unicode.pl
# should line up the leading commas
%low_entities = (    #
                  %iso_8859_low_ents, '255', '376'
                  ,                   '257', '256'
                  ,                   '259', '258'
                  ,                   '261', '260'
                  ,                   '263', '262' );

printf(
    "%s, %2d %s %d %02d:%02d:%02d %s%02d%02d\n",
    ( Sun, Mon, Tue, Wed, Thu, Fri, Sat )[ $localtm[6] ],    # day of week
    $localtm[3],                                             # day of month
    ( Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec )[ $localtm[4] ],    # month
    $localtm[5] + 1900,                                                               # year
    $localtm[2],                                                                      # hour
    $localtm[1],                                                                      # minute
    $localtm[0],                                                                      # sec
    ( $offset >= 0 ) ? '+' : '-',                                                     # TZ offset direction
    abs($offhour),                                                                    # TZ offset hour
    $offmin,                                                                          # TZ offset minute
) || die "822-date: output error: $!\n";

{

    # Examples of alignment oppoturnities for a trailing line
    # would be nice to align the 'rgb->slice' here:
    return ( $l, $rgb->slice("${s},(0)"), $rgb->slice("${s},(1)"), $rgb->slice("${s},(2)") );

    # another example:
    chmod( 0666, $TempFiles{'numeric'}, $TempFiles{'alpha'}, $TempFiles{'blank'} );

    PDL::gl_triangles( ( map { $points->slice($_) } @sls1 ), ( map { $this->{Colors}->slice($_) } @sls1 ) );

    # another - note useless parens
    printf( "%s|%d|\n", substr( $field3, 0, 10 ), ( substr( $field4, 1, 9 ) * 100 ) );

    # break at comma before arrow
    return ( %::PDL_OPTIONS,
             'NAME'         => $mod,
             'VERSION_FROM' => "$w/Basic/Core/Version.pm",
             'TYPEMAPS'     => [ &PDL_TYPEMAP() ],
             'OBJECT'       => "$pref\$(OBJ_EXT)",
             PM             => { "$pref.pm" => "\$(INST_LIBDIR)/$pref.pm" },
             MAN3PODS       => { "$pref.pm" => "\$(INST_MAN3DIR)/$mod.\$(MAN3EXT)" },
             'INC'          => &PDL_INCLUDE(),
             'LIBS'         => [''],
             'clean'        => { 'FILES' => "$pref.xs $pref.pm $pref\$(OBJ_EXT) $pref.c" }, );

    # shouldn't match these:
    $pri = $f2pricf{$f};
    $pri = $sourcedefault{'Priority'} if !length($pri);

    $levels_to_go[$max_index_to_go]        = $level;
    $nesting_depth_to_go[$max_index_to_go] = ( $slevel >= 0 ) ? $slevel : 0;

    # the '=' should align
    local ($article_no) = pop(@_);
    local ($sub_line)   = "";

    # Good alignment example:
    return
        unless ( ( $sl =~ m/^(.*\D)(\d+)\s*o\s*f\s*(\d+)/i ) ||
                 ( $sl =~ m/^(.*\D)(\d+)\s*f\s*o\s*(\d+)/i ) ||
                 ( $sl =~ m/^(.*\D)(\d+)\s*\/\s*(\d+)/ )     ||
                 ( $sl =~ m/^(.*\D)(\d+)\s*\|\s*(\d+)/ )     ||
                 ( $sl =~ m/^(.*\D)(\d+)\s*\\\s*(\d+)/ ) );

    # from Cookbook:
    $page = /Mac/ && 'm/Macintrash.html' ||
        /Win(dows )?NT/  && 'e/evilandrude.html'       ||
        /Win|MSIE|WebTV/ && 'm/MicroslothWindows.html' ||
        /Linux/          && 'l/Linux.html'             ||
        /HP-UX/          && 'h/HP-SUX.html'            ||
        /SunOS/          && 's/ScumOS.html'            ||
        'a/AppendixB.html';

    $self->{RM_F}       ||= "rm -f";
    $self->{RM_RF}      ||= "rm -rf";
    $self->{TOUCH}      ||= "touch";
    $self->{TEST_F}     ||= "test -f";
    $self->{CP}         ||= "cp";
    $self->{MV}         ||= "mv";
    $self->{CHMOD}      ||= "chmod";
    $self->{UMASK_NULL} ||= "umask 0";
    $self->{DEV_NULL}   ||= "> /dev/null 2>&1";

    s/"//                               || next;
    s/",([x\d]+),([x\d]+),([x\d]+),.*// || next;

    if ( $menu_type == 2 ) {
        &print_nl( "a - Select all items.",                                1 );
        &print_nl( "m - Select based on a case-insensitive string match.", 1 );
        &print_nl( "c - Clear all selections.",                            1 );
    }

    $self->{javascriptErrorHandlerBaseWindowName} = "";
    $self->{linkTag}                              = [];
    $self->{baseHrefString}                       = "";
    $self->{baseTargetString}                     = "";
    $self->{linkStyleSheet}                       = "";

    $worksheet->write( 0, 0, "Index",                                $heading );
    $worksheet->write( 0, 1, "Index",                                $heading );
    $worksheet->write( 0, 3, "Style",                                $heading );
    $worksheet->write( 0, 5, "The style is highlighted in red for ", $heading );

    &logr( "              iptables -A INPUT -j DENY\n", $logr_files_aref );
    &logr( "\n",                                        $logr_files_aref );

    {

        # This was an alignment problem once:
        $data = $pkg->new( PeerAddr => join( ".", @port[ 0 .. 3 ] ),
                           PeerPort => $port[4] * 256 + $port[5],
                           Proto    => 'tcp' );

        s/^([^_-]+)_([^_-]+)_([^_-]+)$/$1-$2-$3/ if (/\s/);
        s/_/-/g                                  if (/\s.+\s/);

        print '      <p><i><font size="-1">Disclaimer:</font></i></p>', "\n";
        print '      <p>',                                              "\n";
        print '      <form method="post" action="">',                   "\n";

        {

            # one per line please
            unless ( ( $line =~ /^SUBJECT>/i ) ||
                     ( $line =~ /^ADMIN>/i )                  ||
                     ( $line =~ /^POSTER>/i )                 ||
                     ( $line =~ /^EMAIL>/i )                  ||
                     ( $line =~ /^DATE>/i )                   ||
                     ( $line =~ /^EMAILNOTICES>/i )           ||
                     ( $line =~ /^IP_ADDRESS>/i )             ||
                     ( $line =~ /^<!--/i )                    ||
                     ( $line =~ /^PASSWORD>/i )               ||
                     ( $line =~ /^PREVIOUS>/i )               ||
                     ( $line =~ /^NEXT>/i )                   ||
                     ( $line =~ /^IMAGE>/i )                  ||
                     ( $line =~ /^LINKNAME>/i )               ||
                     ( $line =~ /^LINKURL>/i )                ||
                     ( $line =~ /^<([^>])*>&gt;/i )           ||
                     ( $line =~ /^<([^>])*>$AutoQuoteChar/i ) ||
                     ( $line =~ /^<([^>])*>$/i ) ) {
                $quotedtext .= $line;
            }

            print STDERR "+"                                  if $verbose == 1;
            print STDERR "Error reading $File::Find::name \n" if $verbose == 2;

            {

                print "IF "                          if !$applyall;
                print "<b>[Unconditional Rule]</b> " if $applyall;

            }
        }
    }
}

# alignment of { and = works well here:

while (<DESC>) {
    next if /^#/;
    chop;
    @field = split(' ');
    last if $field[0] eq "charset";
    if ( $field[0] eq "res" )       { $resolution = $field[1]; }
    if ( $field[0] eq "unitwidth" ) { $unitwidth  = $field[1]; }
    if ( $field[0] eq "sizescale" ) { $sizescale  = $field[1]; }
}

# align Numbers and Quotes , and keyword 'unless'
$Indent  = 2     unless defined $Indent;
$Purity  = 0     unless defined $Purity;
$Pad     = ""    unless defined $Pad;
$Varname = "VAR" unless defined $Varname;

# another matrix
my $xyz_shield = [ [ -0.060,  -0.060,  0. ],
                   [ 0.060,   -0.060,  0. ],
                   [ 0.060,   0.060,   0. ],
                   [ -0.060,  0.060,   0. ],
                   [ -0.0925, -0.0925, 0.092 ],
                   [ 0.0925,  -0.0925, 0.092 ],
                   [ 0.0925,  0.0925,  0.092 ],
                   [ -0.0925, 0.0925,  0.092 ], ];

# this used to be aligned, but is not now because of new rules
my ( $num, $numi, $numj, $xyza, $ka, $xyzb, $kb, $aff, $error );
my ( $i, $j, $error, $aff, $asum, $avec );
my ( $km, $area, $varea );

# note that original aligns common word endings - cannot do that
my $classmac_output_file = $outdirname . $schoolcode . "classmac.txt";
my $classpc_output_file  = $outdirname . $schoolcode . "classpc.txt";
my $barmac_output_file   = $outdirname . $schoolcode . "barmac.txt";
my $barpc_output_file    = $outdirname . $schoolcode . "barpc.txt";
close MACOUTFILE;
close PCOUTFILE;
close BARMACOUTFILE;
close BARPCOUTFILE;

# combinations of tokens to line up, with varying line lengths
SWITCH: {
    /phone/ && do { $field = "special", $action = "tel", last SWITCH; };
    /tel/   && do { $field = "special", $action = "tel", last SWITCH; };
    /fax/   && do { $field = "special", $action = "fax", last SWITCH; };
    /birthday/ && do { $field = "birthday", last SWITCH; };
    /email/    && do { $field = "email",    last SWITCH; };
    /letter/   && do { $field = "special",  $action = "letter", last SWITCH; };
}

# At present, a break will be placed after the leading '('
# to simplify lining up the comma-arrows
%accent_type = ( '18' => 'grave',    # \`
                 '19' => 'acute',    # `'
                 '20' => 'caron',    # \v
                 '21' => 'breve',    # \u
                 '22' => 'macr',     # \=
                 '23' => 'ring',     #
                 '24' => 'cedil',    # \c
                 '94' => 'circ',     # \^
                 '95' => 'dot',      # \.
                 '7D' => 'dblac',    # \H
                 '7E' => 'tilde',    # \~
                 '7F' => 'uml',      # \"
);

# This illustrates a problem that can happen with comments:
# Comments do not get moved with hash list items.  That would
# be hard to detect and fix.
my %fallback = (

    # preferred frontend		# fall back to
    'Web'    => 'Gtk',
    'Dialog' => 'Slang',
    'Gtk'    => 'Dialog',
    'Text'   => 'Dialog',
    'Slang'  => 'Dialog', );

{
    {
        {

            # example of some undesirable whitespace added by aligner;
            set_list_breakpoints( $item_count, $identifier_count_stack[$dd], $comma_index[$dd], $interrupted_list[$dd], $max_length[$dd] )
                unless $dont_align[$dd];
        }
    }
}

# two things to note here: (1) this will be broken by the compound list rules,
# (2) vertical alignment is bad because 'undef's are not (yet) allowed
# to match with quotes and numbers.  This needs to be fixed.
my $ti = [ $names, [ 'Not Done Yet', 12, 2000, '\'', '\'', 'max length', 1, 1, 3, undef, '0', '0', undef, undef, undef ] ];

# line up equals, but not commas:
$message     = &rhs_wordwrap( $message, $width );
$message_len = split( /^/,              $message );
$tmp         = $message;

# align all these => with different things to their left:
$str = new Bio::SeqIO(
    '-format' => 'genbank',
    -file     => Bio::Root::IO->catfile( "t", "AF165282.gb" ),
    verbose   => $verbosity
);
